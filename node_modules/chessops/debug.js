"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const util_1 = require("./util");
const fen_1 = require("./fen");
const squareSet_1 = require("./squareSet");
function squareSet(squares) {
    let r = '';
    for (let y = 7; y >= 0; y--) {
        for (let x = 0; x < 8; x++) {
            const square = x + y * 8;
            r += squares.has(square) ? '1' : '.';
            r += x < 7 ? ' ' : '\n';
        }
    }
    return r;
}
exports.squareSet = squareSet;
function piece(piece) {
    return fen_1.makePiece(piece);
}
exports.piece = piece;
function board(board) {
    let r = '';
    for (let y = 7; y >= 0; y--) {
        for (let x = 0; x < 8; x++) {
            const square = x + y * 8;
            const p = board.get(square);
            const col = p ? piece(p) : '.';
            r += col;
            r += x < 7 ? (col.length < 2 ? ' ' : '') : '\n';
        }
    }
    return r;
}
exports.board = board;
function square(sq) {
    return util_1.makeSquare(sq);
}
exports.square = square;
function dests(dests) {
    const lines = [];
    for (const [from, to] of dests) {
        lines.push(`${util_1.makeSquare(from)}: ${Array.from(to, square).join(' ')}`);
    }
    return lines.join('\n');
}
exports.dests = dests;
function perft(pos, depth, log = false) {
    if (depth < 1)
        return 1;
    const promotionRoles = ['queen', 'knight', 'rook', 'bishop'];
    if (pos.rules === 'antichess')
        promotionRoles.push('king');
    const dropDests = pos.dropDests(pos.ctx());
    if (!log && depth === 1 && dropDests.isEmpty()) {
        // Optimization for leaf nodes.
        let nodes = 0;
        for (const [from, to] of pos.allDests()) {
            nodes += to.size();
            if (pos.board.pawn.has(from)) {
                const backrank = squareSet_1.SquareSet.backrank(util_1.opposite(pos.turn));
                nodes += to.intersect(backrank).size() * (promotionRoles.length - 1);
            }
        }
        return nodes;
    }
    else {
        let nodes = 0;
        for (const [from, dests] of pos.allDests()) {
            const promotions = ((from >> 3) === (pos.turn === 'white' ? 6 : 1) && pos.board.pawn.has(from)) ?
                promotionRoles : [undefined];
            for (const to of dests) {
                for (const promotion of promotions) {
                    const child = pos.clone();
                    const uci = { from, to, promotion };
                    child.play(uci);
                    const children = perft(child, depth - 1, false);
                    if (log)
                        console.log(util_1.makeUci(uci), children);
                    nodes += children;
                }
            }
        }
        if (pos.pockets) {
            for (const role of types_1.ROLES) {
                if (pos.pockets[pos.turn][role] > 0) {
                    for (const to of (role === 'pawn' ? dropDests.diff(squareSet_1.SquareSet.backranks()) : dropDests)) {
                        const child = pos.clone();
                        const uci = { role, to };
                        child.play(uci);
                        const children = perft(child, depth - 1, false);
                        if (log)
                            console.log(util_1.makeUci(uci), children);
                        nodes += children;
                    }
                }
            }
        }
        return nodes;
    }
}
exports.perft = perft;
