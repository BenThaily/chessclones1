"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
function defined(v) {
    return typeof v !== 'undefined';
}
exports.defined = defined;
function opposite(color) {
    return color === 'white' ? 'black' : 'white';
}
exports.opposite = opposite;
function squareDist(a, b) {
    const x1 = a & 0x7, x2 = b & 0x7;
    const y1 = a >> 3, y2 = b >> 3;
    return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
}
exports.squareDist = squareDist;
function squareRank(square) {
    return square >> 3;
}
exports.squareRank = squareRank;
function squareFile(square) {
    return square & 0x7;
}
exports.squareFile = squareFile;
function roleToChar(role) {
    switch (role) {
        case 'pawn': return 'p';
        case 'knight': return 'n';
        case 'bishop': return 'b';
        case 'rook': return 'r';
        case 'queen': return 'q';
        case 'king': return 'k';
    }
}
exports.roleToChar = roleToChar;
function charToRole(ch) {
    switch (ch) {
        case 'P':
        case 'p': return 'pawn';
        case 'N':
        case 'n': return 'knight';
        case 'B':
        case 'b': return 'bishop';
        case 'R':
        case 'r': return 'rook';
        case 'Q':
        case 'q': return 'queen';
        case 'K':
        case 'k': return 'king';
        default: return;
    }
}
exports.charToRole = charToRole;
function parseSquare(str) {
    if (!/^[a-h][1-8]$/.test(str))
        return;
    return str.charCodeAt(0) - 'a'.charCodeAt(0) + 8 * (str.charCodeAt(1) - '1'.charCodeAt(0));
}
exports.parseSquare = parseSquare;
function makeSquare(square) {
    return 'abcdefgh'[square & 0x7] + '12345678'[square >> 3];
}
exports.makeSquare = makeSquare;
function parseUci(str) {
    if (str[1] === '@' && str.length === 4) {
        const role = charToRole(str[0]);
        const to = parseSquare(str.slice(2));
        if (role && defined(to))
            return { role, to };
    }
    else if (str.length === 4 || str.length === 5) {
        const from = parseSquare(str.slice(0, 2));
        const to = parseSquare(str.slice(2, 4));
        let promotion;
        if (str.length === 5) {
            promotion = charToRole(str[4]);
            if (!promotion)
                return;
        }
        if (defined(from) && defined(to))
            return { from, to, promotion };
    }
    return;
}
exports.parseUci = parseUci;
function makeUci(uci) {
    if (types_1.isDrop(uci))
        return `${roleToChar(uci.role).toUpperCase()}@${makeSquare(uci.to)}`;
    return makeSquare(uci.from) + makeSquare(uci.to) + (uci.promotion ? roleToChar(uci.promotion) : '');
}
exports.makeUci = makeUci;
