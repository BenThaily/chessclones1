"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const result_1 = require("@badrap/result");
const types_1 = require("./types");
const squareSet_1 = require("./squareSet");
const board_1 = require("./board");
const attacks_1 = require("./attacks");
const util_1 = require("./util");
var IllegalSetup;
(function (IllegalSetup) {
    IllegalSetup["Empty"] = "ERR_EMPTY";
    IllegalSetup["OppositeCheck"] = "ERR_OPPOSITE_CHECK";
    IllegalSetup["PawnsOnBackrank"] = "ERR_PAWNS_ON_BACKRANK";
    IllegalSetup["Kings"] = "ERR_KINGS";
    IllegalSetup["Variant"] = "ERR_VARIANT";
})(IllegalSetup = exports.IllegalSetup || (exports.IllegalSetup = {}));
class PositionError extends Error {
}
exports.PositionError = PositionError;
function attacksTo(square, attacker, board, occupied) {
    return board[attacker].intersect(attacks_1.rookAttacks(square, occupied).intersect(board.rooksAndQueens())
        .union(attacks_1.bishopAttacks(square, occupied).intersect(board.bishopsAndQueens()))
        .union(attacks_1.knightAttacks(square).intersect(board.knight))
        .union(attacks_1.kingAttacks(square).intersect(board.king))
        .union(attacks_1.pawnAttacks(util_1.opposite(attacker), square).intersect(board.pawn)));
}
function kingCastlesTo(color, side) {
    return color === 'white' ? (side === 'a' ? 2 : 6) : (side === 'a' ? 58 : 62);
}
function rookCastlesTo(color, side) {
    return color === 'white' ? (side === 'a' ? 3 : 5) : (side === 'a' ? 59 : 61);
}
class Castles {
    constructor() { }
    static default() {
        const castles = new Castles();
        castles.unmovedRooks = squareSet_1.SquareSet.corners();
        castles.rook = {
            white: { a: 0, h: 7 },
            black: { a: 56, h: 63 },
        };
        castles.path = {
            white: { a: new squareSet_1.SquareSet(0x60, 0), h: new squareSet_1.SquareSet(0, 0xe) },
            black: { a: new squareSet_1.SquareSet(0, 0x60000000), h: new squareSet_1.SquareSet(0, 0x0e000000) },
        };
        return castles;
    }
    static empty() {
        const castles = new Castles();
        castles.unmovedRooks = squareSet_1.SquareSet.empty();
        castles.rook = {
            white: { a: undefined, h: undefined },
            black: { a: undefined, h: undefined },
        };
        castles.path = {
            white: { a: squareSet_1.SquareSet.empty(), h: squareSet_1.SquareSet.empty() },
            black: { a: squareSet_1.SquareSet.empty(), h: squareSet_1.SquareSet.empty() },
        };
        return castles;
    }
    clone() {
        const castles = new Castles();
        castles.unmovedRooks = this.unmovedRooks;
        castles.rook = {
            white: { a: this.rook.white.a, h: this.rook.white.h },
            black: { a: this.rook.black.a, h: this.rook.black.h },
        };
        castles.path = {
            white: { a: this.path.white.a, h: this.path.white.h },
            black: { a: this.path.black.a, h: this.path.black.h },
        };
        return castles;
    }
    add(color, side, king, rook) {
        const kingTo = kingCastlesTo(color, side);
        const rookTo = rookCastlesTo(color, side);
        this.unmovedRooks = this.unmovedRooks.with(rook);
        this.rook[color][side] = rook;
        this.path[color][side] = attacks_1.between(rook, rookTo).with(rookTo)
            .union(attacks_1.between(king, kingTo).with(kingTo))
            .without(king).without(rook);
    }
    static fromSetup(setup) {
        const castles = Castles.empty();
        const rooks = setup.unmovedRooks.intersect(setup.board.rook);
        for (const color of types_1.COLORS) {
            const backrank = squareSet_1.SquareSet.backrank(color);
            const king = setup.board.kingOf(color);
            if (!util_1.defined(king) || !backrank.has(king))
                continue;
            const side = rooks.intersect(setup.board[color]).intersect(backrank);
            const aSide = side.first();
            if (util_1.defined(aSide) && aSide < king)
                castles.add(color, 'a', king, aSide);
            const hSide = side.last();
            if (util_1.defined(hSide) && king < hSide)
                castles.add(color, 'h', king, hSide);
        }
        return castles;
    }
    discardRook(square) {
        if (this.unmovedRooks.has(square)) {
            this.unmovedRooks = this.unmovedRooks.without(square);
            for (const color of types_1.COLORS) {
                for (const side of types_1.CASTLING_SIDES) {
                    if (this.rook[color][side] === square)
                        this.rook[color][side] = undefined;
                }
            }
        }
    }
    discardSide(color) {
        this.unmovedRooks = this.unmovedRooks.diff(squareSet_1.SquareSet.backrank(color));
        this.rook[color].a = undefined;
        this.rook[color].h = undefined;
    }
}
exports.Castles = Castles;
class Position {
    constructor(rules) {
        this.rules = rules;
    }
    kingAttackers(square, attacker, occupied) {
        return attacksTo(square, attacker, this.board, occupied);
    }
    dropDests(_ctx) {
        return squareSet_1.SquareSet.empty();
    }
    playCaptureAt(square, captured) {
        this.halfmoves = 0;
        if (captured.role === 'rook')
            this.castles.discardRook(square);
        if (this.pockets)
            this.pockets[util_1.opposite(captured.color)][captured.role]++;
    }
    ctx() {
        const variantEnd = this.isVariantEnd();
        const king = this.board.kingOf(this.turn);
        if (!util_1.defined(king))
            return { king, blockers: squareSet_1.SquareSet.empty(), checkers: squareSet_1.SquareSet.empty(), variantEnd, mustCapture: false };
        const snipers = attacks_1.rookAttacks(king, squareSet_1.SquareSet.empty()).intersect(this.board.rooksAndQueens())
            .union(attacks_1.bishopAttacks(king, squareSet_1.SquareSet.empty()).intersect(this.board.bishopsAndQueens()))
            .intersect(this.board[util_1.opposite(this.turn)]);
        let blockers = squareSet_1.SquareSet.empty();
        for (const sniper of snipers) {
            const b = attacks_1.between(king, sniper).intersect(this.board.occupied);
            if (!b.moreThanOne())
                blockers = blockers.union(b);
        }
        const checkers = this.kingAttackers(king, util_1.opposite(this.turn), this.board.occupied);
        return {
            king,
            blockers,
            checkers,
            variantEnd,
            mustCapture: false,
        };
    }
    // The following should be identical in all subclasses
    clone() {
        const pos = new this.constructor();
        pos.board = this.board.clone();
        pos.pockets = this.pockets && this.pockets.clone();
        pos.turn = this.turn;
        pos.castles = this.castles.clone();
        pos.epSquare = this.epSquare;
        pos.remainingChecks = this.remainingChecks && this.remainingChecks.clone();
        pos.halfmoves = this.halfmoves;
        pos.fullmoves = this.fullmoves;
        return pos;
    }
    toSetup() {
        return {
            board: this.board.clone(),
            pockets: this.pockets && this.pockets.clone(),
            turn: this.turn,
            unmovedRooks: this.castles.unmovedRooks,
            epSquare: this.hasLegalEp() ? this.epSquare : undefined,
            remainingChecks: this.remainingChecks && this.remainingChecks.clone(),
            halfmoves: Math.min(this.halfmoves, 150),
            fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999),
        };
    }
    isInsufficientMaterial() {
        return types_1.COLORS.every(color => this.hasInsufficientMaterial(color));
    }
    hasDests(ctx) {
        for (const square of this.board[this.turn]) {
            if (this.dests(square, ctx).nonEmpty())
                return true;
        }
        return this.dropDests(ctx).nonEmpty();
    }
    isLegal(uci, ctx) {
        if (types_1.isDrop(uci)) {
            if (!this.pockets || this.pockets[this.turn][uci.role] <= 0)
                return false;
            if (uci.role === 'pawn' && squareSet_1.SquareSet.backranks().has(uci.to))
                return false;
            return this.dropDests(ctx).has(uci.to);
        }
        else {
            if (uci.promotion === 'pawn')
                return false;
            if (uci.promotion === 'king' && this.rules !== 'antichess')
                return false;
            if (!uci.promotion && this.board.pawn.has(uci.from) && squareSet_1.SquareSet.backranks().has(uci.to))
                return false;
            return this.dests(uci.from, ctx).has(uci.to);
        }
    }
    isCheck() {
        const king = this.board.kingOf(this.turn);
        return util_1.defined(king) && this.kingAttackers(king, util_1.opposite(this.turn), this.board.occupied).nonEmpty();
    }
    isEnd() {
        return this.isVariantEnd() || this.isInsufficientMaterial() || !this.hasDests(this.ctx());
    }
    isCheckmate() {
        if (this.isVariantEnd())
            return false;
        const ctx = this.ctx();
        return ctx.checkers.nonEmpty() && !this.hasDests(ctx);
    }
    isStalemate() {
        if (this.isVariantEnd())
            return false;
        const ctx = this.ctx();
        return ctx.checkers.isEmpty() && !this.hasDests(ctx);
    }
    outcome() {
        const variantOutcome = this.variantOutcome();
        if (variantOutcome)
            return variantOutcome;
        else if (this.isCheckmate())
            return { winner: util_1.opposite(this.turn) };
        else if (this.isInsufficientMaterial() || this.isStalemate())
            return { winner: undefined };
        else
            return;
    }
    allDests() {
        const ctx = this.ctx();
        const d = new Map();
        if (ctx.variantEnd)
            return d;
        for (const square of this.board[this.turn]) {
            d.set(square, this.dests(square, ctx));
        }
        return d;
    }
    play(uci) {
        const turn = this.turn, epSquare = this.epSquare;
        this.epSquare = undefined;
        this.halfmoves += 1;
        if (turn === 'black')
            this.fullmoves += 1;
        this.turn = util_1.opposite(turn);
        if (types_1.isDrop(uci)) {
            this.board.set(uci.to, { role: uci.role, color: turn });
            if (this.pockets)
                this.pockets[turn][uci.role]--;
            if (uci.role === 'pawn')
                this.halfmoves = 0;
        }
        else {
            const piece = this.board.take(uci.from);
            if (!piece)
                return;
            let epCapture;
            if (piece.role === 'pawn') {
                this.halfmoves = 0;
                if (uci.to === epSquare) {
                    epCapture = this.board.take(uci.to + (turn === 'white' ? -8 : 8));
                }
                const delta = uci.from - uci.to;
                if (Math.abs(delta) === 16 && 8 <= uci.from && uci.from <= 55) {
                    this.epSquare = (uci.from + uci.to) >> 1;
                }
                if (uci.promotion) {
                    piece.role = uci.promotion;
                    piece.promoted = true;
                }
            }
            else if (piece.role === 'rook') {
                this.castles.discardRook(uci.from);
            }
            else if (piece.role === 'king') {
                const delta = uci.to - uci.from;
                const isCastling = Math.abs(delta) === 2 || this.board[turn].has(uci.to);
                if (isCastling) {
                    const side = delta > 0 ? 'h' : 'a';
                    const rookFrom = this.castles.rook[turn][side];
                    if (util_1.defined(rookFrom)) {
                        const rook = this.board.take(rookFrom);
                        this.board.set(kingCastlesTo(turn, side), piece);
                        if (rook)
                            this.board.set(rookCastlesTo(turn, side), rook);
                    }
                }
                this.castles.discardSide(turn);
                if (isCastling)
                    return;
            }
            const capture = this.board.set(uci.to, piece) || epCapture;
            if (capture)
                this.playCaptureAt(uci.to, capture);
        }
    }
    hasLegalEp() {
        if (!this.epSquare)
            return false;
        const ctx = this.ctx();
        const ourPawns = this.board.pieces(this.turn, 'pawn');
        const candidates = ourPawns.intersect(attacks_1.pawnAttacks(util_1.opposite(this.turn), this.epSquare));
        for (const candidate of candidates) {
            if (this.dests(candidate, ctx).has(this.epSquare))
                return true;
        }
        return false;
    }
}
exports.Position = Position;
class Chess extends Position {
    constructor(rules) {
        super(rules || 'chess');
    }
    static default() {
        const pos = new this();
        pos.board = board_1.Board.default();
        pos.pockets = undefined;
        pos.turn = 'white';
        pos.castles = Castles.default();
        pos.epSquare = undefined;
        pos.remainingChecks = undefined;
        pos.halfmoves = 0;
        pos.fullmoves = 1;
        return pos;
    }
    static fromSetup(setup) {
        const pos = new this();
        pos.board = setup.board.clone();
        pos.pockets = undefined;
        pos.turn = setup.turn;
        pos.castles = Castles.fromSetup(setup);
        pos.epSquare = pos.validEpSquare(setup.epSquare);
        pos.remainingChecks = undefined;
        pos.halfmoves = setup.halfmoves;
        pos.fullmoves = setup.fullmoves;
        return pos.validate().map(_ => pos);
    }
    clone() {
        return super.clone();
    }
    validate() {
        if (this.board.occupied.isEmpty())
            return result_1.Result.err(new PositionError(IllegalSetup.Empty));
        if (this.board.king.size() !== 2)
            return result_1.Result.err(new PositionError(IllegalSetup.Kings));
        if (!util_1.defined(this.board.kingOf(this.turn)))
            return result_1.Result.err(new PositionError(IllegalSetup.Kings));
        const otherKing = this.board.kingOf(util_1.opposite(this.turn));
        if (!util_1.defined(otherKing))
            return result_1.Result.err(new PositionError(IllegalSetup.Kings));
        if (this.kingAttackers(otherKing, this.turn, this.board.occupied).nonEmpty()) {
            return result_1.Result.err(new PositionError(IllegalSetup.OppositeCheck));
        }
        if (squareSet_1.SquareSet.backranks().intersects(this.board.pawn)) {
            return result_1.Result.err(new PositionError(IllegalSetup.PawnsOnBackrank));
        }
        return result_1.Result.ok(undefined);
    }
    validEpSquare(square) {
        if (!square)
            return;
        const epRank = this.turn === 'white' ? 5 : 2;
        const forward = this.turn === 'white' ? 8 : -8;
        if ((square >> 3) !== epRank)
            return;
        if (this.board.occupied.has(square + forward))
            return;
        const pawn = square - forward;
        if (!this.board.pawn.has(pawn) || !this.board[util_1.opposite(this.turn)].has(pawn))
            return;
        return square;
    }
    castlingDest(side, ctx) {
        if (!util_1.defined(ctx.king) || ctx.checkers.nonEmpty())
            return squareSet_1.SquareSet.empty();
        const rook = this.castles.rook[this.turn][side];
        if (!util_1.defined(rook))
            return squareSet_1.SquareSet.empty();
        if (this.castles.path[this.turn][side].intersects(this.board.occupied))
            return squareSet_1.SquareSet.empty();
        const kingTo = kingCastlesTo(this.turn, side);
        const kingPath = attacks_1.between(ctx.king, kingTo);
        const occ = this.board.occupied.without(ctx.king);
        for (const sq of kingPath) {
            if (this.kingAttackers(sq, util_1.opposite(this.turn), occ).nonEmpty())
                return squareSet_1.SquareSet.empty();
        }
        const rookTo = rookCastlesTo(this.turn, side);
        const after = this.board.occupied.toggle(ctx.king).toggle(rook).toggle(rookTo);
        if (this.kingAttackers(kingTo, util_1.opposite(this.turn), after).nonEmpty())
            return squareSet_1.SquareSet.empty();
        return squareSet_1.SquareSet.fromSquare(rook);
    }
    canCaptureEp(pawn, ctx) {
        if (!util_1.defined(this.epSquare))
            return false;
        if (!attacks_1.pawnAttacks(this.turn, pawn).has(this.epSquare))
            return false;
        if (!util_1.defined(ctx.king))
            return true;
        const captured = this.epSquare + ((this.turn === 'white') ? -8 : 8);
        const occupied = this.board.occupied.toggle(pawn).toggle(this.epSquare).toggle(captured);
        return !this.kingAttackers(ctx.king, util_1.opposite(this.turn), occupied).intersects(occupied);
    }
    pseudoDests(square, ctx) {
        if (ctx.variantEnd)
            return squareSet_1.SquareSet.empty();
        const piece = this.board.get(square);
        if (!piece || piece.color !== this.turn)
            return squareSet_1.SquareSet.empty();
        let pseudo = attacks_1.attacks(piece, square, this.board.occupied);
        if (piece.role === 'pawn') {
            let captureTargets = this.board[util_1.opposite(this.turn)];
            if (util_1.defined(this.epSquare))
                captureTargets = captureTargets.with(this.epSquare);
            pseudo = pseudo.intersect(captureTargets);
            const delta = this.turn === 'white' ? 8 : -8;
            const step = square + delta;
            if (0 <= step && step < 64 && !this.board.occupied.has(step)) {
                pseudo = pseudo.with(step);
                const canDoubleStep = this.turn === 'white' ? (square < 16) : (square >= 64 - 16);
                const doubleStep = step + delta;
                if (canDoubleStep && !this.board.occupied.has(doubleStep)) {
                    pseudo = pseudo.with(doubleStep);
                }
            }
            return pseudo;
        }
        else {
            pseudo = pseudo.diff(this.board[this.turn]);
        }
        if (square === ctx.king)
            return pseudo.union(this.castlingDest('a', ctx)).union(this.castlingDest('h', ctx));
        else
            return pseudo;
    }
    dests(square, ctx) {
        if (ctx.variantEnd)
            return squareSet_1.SquareSet.empty();
        const piece = this.board.get(square);
        if (!piece || piece.color !== this.turn)
            return squareSet_1.SquareSet.empty();
        let pseudo, legal;
        if (piece.role === 'pawn') {
            pseudo = attacks_1.pawnAttacks(this.turn, square).intersect(this.board[util_1.opposite(this.turn)]);
            const delta = this.turn === 'white' ? 8 : -8;
            const step = square + delta;
            if (0 <= step && step < 64 && !this.board.occupied.has(step)) {
                pseudo = pseudo.with(step);
                const canDoubleStep = this.turn === 'white' ? (square < 16) : (square >= 64 - 16);
                const doubleStep = step + delta;
                if (canDoubleStep && !this.board.occupied.has(doubleStep)) {
                    pseudo = pseudo.with(doubleStep);
                }
            }
            if (util_1.defined(this.epSquare) && this.canCaptureEp(square, ctx)) {
                const pawn = this.epSquare - delta;
                if (ctx.checkers.isEmpty() || ctx.checkers.singleSquare() === pawn) {
                    legal = squareSet_1.SquareSet.fromSquare(this.epSquare);
                }
            }
        }
        else if (piece.role === 'bishop')
            pseudo = attacks_1.bishopAttacks(square, this.board.occupied);
        else if (piece.role === 'knight')
            pseudo = attacks_1.knightAttacks(square);
        else if (piece.role === 'rook')
            pseudo = attacks_1.rookAttacks(square, this.board.occupied);
        else if (piece.role === 'queen')
            pseudo = attacks_1.queenAttacks(square, this.board.occupied);
        else
            pseudo = attacks_1.kingAttacks(square);
        pseudo = pseudo.diff(this.board[this.turn]);
        if (util_1.defined(ctx.king)) {
            if (piece.role === 'king') {
                const occ = this.board.occupied.without(square);
                for (const to of pseudo) {
                    if (this.kingAttackers(to, util_1.opposite(this.turn), occ).nonEmpty())
                        pseudo = pseudo.without(to);
                }
                return pseudo.union(this.castlingDest('a', ctx)).union(this.castlingDest('h', ctx));
            }
            if (ctx.checkers.nonEmpty()) {
                const checker = ctx.checkers.singleSquare();
                if (!util_1.defined(checker))
                    return squareSet_1.SquareSet.empty();
                pseudo = pseudo.intersect(attacks_1.between(checker, ctx.king).with(checker));
            }
            if (ctx.blockers.has(square))
                pseudo = pseudo.intersect(attacks_1.ray(square, ctx.king));
        }
        if (legal)
            pseudo = pseudo.union(legal);
        return pseudo;
    }
    isVariantEnd() {
        return false;
    }
    variantOutcome() {
        return;
    }
    hasInsufficientMaterial(color) {
        if (this.board[color].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty())
            return false;
        if (this.board[color].intersects(this.board.knight)) {
            return this.board[color].size() <= 2 &&
                this.board[util_1.opposite(color)].diff(this.board.king).diff(this.board.queen).isEmpty();
        }
        if (this.board[color].intersects(this.board.bishop)) {
            const sameColor = !this.board.bishop.intersects(squareSet_1.SquareSet.darkSquares()) ||
                !this.board.bishop.intersects(squareSet_1.SquareSet.lightSquares());
            return sameColor && this.board[util_1.opposite(color)].diff(this.board.king).diff(this.board.rook).diff(this.board.queen).isEmpty();
        }
        return true;
    }
}
exports.Chess = Chess;
