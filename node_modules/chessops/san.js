"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const util_1 = require("./util");
const squareSet_1 = require("./squareSet");
const attacks_1 = require("./attacks");
function makeSanWithoutSuffix(pos, uci) {
    let san = '';
    if (types_1.isDrop(uci)) {
        if (uci.role !== 'pawn')
            san = util_1.roleToChar(uci.role).toUpperCase();
        san += '@' + util_1.makeSquare(uci.to);
    }
    else {
        const role = pos.board.getRole(uci.from);
        if (!role)
            return '--';
        if (role === 'king' && (pos.board[pos.turn].has(uci.to) || Math.abs(uci.to - uci.from) === 2)) {
            san = uci.to > uci.from ? 'O-O' : 'O-O-O';
        }
        else {
            const capture = pos.board.occupied.has(uci.to) || (role === 'pawn' && (uci.from & 0x7) !== (uci.to & 0x7));
            if (role !== 'pawn') {
                san = util_1.roleToChar(role).toUpperCase();
                // Disambiguation
                let others;
                if (role === 'king')
                    others = attacks_1.kingAttacks(uci.to).intersect(pos.board.king);
                else if (role === 'queen')
                    others = attacks_1.queenAttacks(uci.to, pos.board.occupied).intersect(pos.board.queen);
                else if (role === 'rook')
                    others = attacks_1.rookAttacks(uci.to, pos.board.occupied).intersect(pos.board.rook);
                else if (role === 'bishop')
                    others = attacks_1.bishopAttacks(uci.to, pos.board.occupied).intersect(pos.board.bishop);
                else
                    others = attacks_1.knightAttacks(uci.to).intersect(pos.board.knight);
                others = others.intersect(pos.board[pos.turn]).without(uci.from);
                if (others.nonEmpty()) {
                    const ctx = pos.ctx();
                    for (const from of others) {
                        if (!pos.dests(from, ctx).has(uci.to))
                            others = others.without(from);
                    }
                    if (others.nonEmpty()) {
                        let row = false;
                        let column = others.intersects(squareSet_1.SquareSet.fromRank(uci.from >> 3));
                        if (others.intersects(squareSet_1.SquareSet.fromFile(uci.from & 0x7)))
                            row = true;
                        else
                            column = true;
                        if (column)
                            san += 'abcdefgh'[uci.from & 0x7];
                        if (row)
                            san += '12345678'[uci.from >> 3];
                    }
                }
            }
            else if (capture)
                san = 'abcdefgh'[uci.from & 0x7];
            if (capture)
                san += 'x';
            san += util_1.makeSquare(uci.to);
            if (uci.promotion)
                san += '=' + util_1.roleToChar(uci.promotion).toUpperCase();
        }
    }
    return san;
}
function makeSanAndPlay(pos, uci) {
    const san = makeSanWithoutSuffix(pos, uci);
    pos.play(uci);
    const outcome = pos.outcome();
    if (outcome && outcome.winner)
        return san + '#';
    else if (pos.isCheck())
        return san + '+';
    else
        return san;
}
exports.makeSanAndPlay = makeSanAndPlay;
function makeSanVariation(pos, variation) {
    pos = pos.clone();
    let line = '';
    for (let i = 0; i < variation.length; i++) {
        if (i !== 0)
            line += ' ';
        if (pos.turn === 'white')
            line += pos.fullmoves + '. ';
        else if (i === 0)
            line = pos.fullmoves + '... ';
        const san = makeSanWithoutSuffix(pos, variation[i]);
        pos.play(variation[i]);
        line += san;
        if (san === '--')
            return line;
        let over = false;
        if (i === variation.length - 1) {
            const outcome = pos.outcome();
            over = !!(outcome && outcome.winner);
        }
        if (over)
            line += '#';
        else if (pos.isCheck())
            line += '+';
    }
    return line;
}
exports.makeSanVariation = makeSanVariation;
function makeSan(pos, uci) {
    return makeSanAndPlay(pos.clone(), uci);
}
exports.makeSan = makeSan;
