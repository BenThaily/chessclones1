"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
const squareSet_1 = require("./squareSet");
function computeRange(square, deltas, stepper) {
    let range = squareSet_1.SquareSet.empty();
    for (const delta of deltas) {
        for (let sq = square + delta; 0 <= sq && sq < 64 && util_1.squareDist(sq, sq - delta) <= 2; sq += delta) {
            range = range.with(sq);
            if (stepper)
                break;
        }
    }
    return range;
}
function computeTable(deltas, stepper) {
    const table = [];
    for (let square = 0; square < 64; square++) {
        table[square] = computeRange(square, deltas, stepper);
    }
    return table;
}
const KING_ATTACKS = computeTable([-9, -8, -7, -1, 1, 7, 8, 9], true);
const KNIGHT_ATTACKS = computeTable([-17, -15, -10, -6, 6, 10, 15, 17], true);
const PAWN_ATTACKS = {
    white: computeTable([7, 9], true),
    black: computeTable([-7, -9], true),
};
function kingAttacks(square) {
    return KING_ATTACKS[square];
}
exports.kingAttacks = kingAttacks;
function knightAttacks(square) {
    return KNIGHT_ATTACKS[square];
}
exports.knightAttacks = knightAttacks;
function pawnAttacks(color, square) {
    return PAWN_ATTACKS[color][square];
}
exports.pawnAttacks = pawnAttacks;
const FILE_RANGE = computeTable([-8, 8], false);
const RANK_RANGE = computeTable([-1, 1], false);
const DIAG_RANGE = computeTable([-9, 9], false);
const ANTI_DIAG_RANGE = computeTable([-7, 7], false);
function hyperbola(bit, range, occupied) {
    let forward = occupied.intersect(range);
    let reverse = forward.bswap64(); // Assumes no more than 1 bit per rank
    forward = forward.minus64(bit);
    reverse = reverse.minus64(bit.bswap64());
    forward = forward.xor(reverse.bswap64());
    return forward.intersect(range);
}
function fileAttacks(square, occupied) {
    return hyperbola(squareSet_1.SquareSet.fromSquare(square), FILE_RANGE[square], occupied);
}
function rankAttacks(square, occupied) {
    const range = RANK_RANGE[square];
    let forward = occupied.intersect(range);
    let reverse = forward.rbit64();
    forward = forward.minus64(squareSet_1.SquareSet.fromSquare(square));
    reverse = reverse.minus64(squareSet_1.SquareSet.fromSquare(63 - square));
    forward = forward.xor(reverse.rbit64());
    return forward.intersect(range);
}
function diagAttacks(square, occupied) {
    return hyperbola(squareSet_1.SquareSet.fromSquare(square), DIAG_RANGE[square], occupied);
}
function antiDiagAttacks(square, occupied) {
    return hyperbola(squareSet_1.SquareSet.fromSquare(square), ANTI_DIAG_RANGE[square], occupied);
}
function bishopAttacks(square, occupied) {
    const bit = squareSet_1.SquareSet.fromSquare(square);
    return hyperbola(bit, DIAG_RANGE[square], occupied).xor(hyperbola(bit, ANTI_DIAG_RANGE[square], occupied));
}
exports.bishopAttacks = bishopAttacks;
function rookAttacks(square, occupied) {
    return fileAttacks(square, occupied).xor(rankAttacks(square, occupied));
}
exports.rookAttacks = rookAttacks;
function queenAttacks(square, occupied) {
    return bishopAttacks(square, occupied).xor(rookAttacks(square, occupied));
}
exports.queenAttacks = queenAttacks;
function attacks(piece, square, occupied) {
    switch (piece.role) {
        case 'pawn': return pawnAttacks(piece.color, square);
        case 'knight': return knightAttacks(square);
        case 'bishop': return bishopAttacks(square, occupied);
        case 'rook': return rookAttacks(square, occupied);
        case 'queen': return queenAttacks(square, occupied);
        case 'king': return kingAttacks(square);
    }
}
exports.attacks = attacks;
function rayTables() {
    const ray = [];
    const between = [];
    const zero = squareSet_1.SquareSet.empty();
    for (let a = 0; a < 64; a++) {
        ray[a] = [];
        between[a] = [];
        for (let b = 0; b < 64; b++) {
            ray[a][b] = zero;
            between[a][b] = zero;
        }
        for (const b of DIAG_RANGE[a]) {
            ray[a][b] = DIAG_RANGE[a].with(a);
            between[a][b] = diagAttacks(a, squareSet_1.SquareSet.fromSquare(b)).intersect(diagAttacks(b, squareSet_1.SquareSet.fromSquare(a)));
        }
        for (const b of ANTI_DIAG_RANGE[a]) {
            ray[a][b] = ANTI_DIAG_RANGE[a].with(a);
            between[a][b] = antiDiagAttacks(a, squareSet_1.SquareSet.fromSquare(b)).intersect(antiDiagAttacks(b, squareSet_1.SquareSet.fromSquare(a)));
        }
        for (const b of FILE_RANGE[a]) {
            ray[a][b] = FILE_RANGE[a].with(a);
            between[a][b] = fileAttacks(a, squareSet_1.SquareSet.fromSquare(b)).intersect(fileAttacks(b, squareSet_1.SquareSet.fromSquare(a)));
        }
        for (const b of RANK_RANGE[a]) {
            ray[a][b] = RANK_RANGE[a].with(a);
            between[a][b] = rankAttacks(a, squareSet_1.SquareSet.fromSquare(b)).intersect(rankAttacks(b, squareSet_1.SquareSet.fromSquare(a)));
        }
    }
    return [ray, between];
}
const [RAY, BETWEEN] = rayTables();
function ray(a, b) {
    return RAY[a][b];
}
exports.ray = ray;
function between(a, b) {
    return BETWEEN[a][b];
}
exports.between = between;
